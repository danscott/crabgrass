#  This is a generic versioned wiki, primarily used by the WikiPage,
#  but also used directly sometimes by other classes (like for Group's
#  landing page wiki's).
#
#     create_table "wiki_versions", :force => true do |t|
#       t.integer  "wiki_id",    :limit => 11
#       t.integer  "version",    :limit => 11
#       t.text     "body"
#       t.text     "body_html"
#       t.datetime "updated_at"
#       t.integer  "user_id",    :limit => 11
#     end
#
#     add_index "wiki_versions", ["wiki_id"], :name => "index_wiki_versions"
#     add_index "wiki_versions", ["wiki_id", "updated_at"], :name => "index_wiki_versions_with_updated_at"
#
#     create_table "wikis", :force => true do |t|
#       t.text     "body"
#       t.text     "body_html"
#       t.datetime "updated_at"
#       t.integer  "user_id",      :limit => 11
#       t.integer  "version",      :limit => 11
#       t.integer  "lock_version", :limit => 11, :default => 0
#       t.text     "edit_locks"
#     end
#
#     add_index "wikis", ["user_id"], :name => "index_wikis_user_id"
#

class Wiki < ActiveRecord::Base

  serialize :edit_locks, Array

  belongs_to :user

  # a wiki can be used in multiple places: pages or profiles
  has_many :pages, :as => :data
  has_one :profile
  
  ##
  ## LOCKING
  ##

  # a word about timezones:
  # to get an attribute in UTC, you must do:
  #   wiki.locked_at_before_type_cast 
  # otherwise, the times reported by active record objects
  # are always local.

  LOCKING_PERIOD = 120.minutes

  # locks this wiki so that it cannot be edited by anothe user.
  def lock(time, locked_by, section = :all)
    time = time.utc
    lock = {:locked_section => section, :update_section => section,
      :locked_at => time, :locked_by_id => locked_by.id}

    # save without versions or timestamps
    update_edit_locks_attribute(edit_locks + [lock])
  end

  # unlocks a previously locked wiki (or a section) so that it can be edited by anyone.
  def unlock(locked_by = nil, section = :all)
    updated_locks = nil

    if section == :all
      # wipe away everything
      updated_locks = []
    elsif locked_by
      # we have a user and a section
      updated_locks = edit_locks.reject do |lock|
        lock[:locked_by_id] == locked_by.id and lock[:update_section] == section
      end
    else
      # we only know the section
      updated_locks = edit_locks.reject do |lock|
        lock[:update_section] == section
      end
    end

    # save without versions or timestamps
    update_edit_locks_attribute(updated_locks) unless updated_locks.nil?

  end

  # returns true if +section+ is locked by anyone
  def locked?(section = :all)
    update_expired_locks unless @expired_locks_updated

    # find a lock for this section or all sections
    return edit_locks.detect {|lock| lock[:update_section] == section or lock[:update_section] == :all}
  end
  
  # returns true if the page is free to be edited by +user+ (ie, not locked by someone else)
  def editable_by?(user, section = :all)
    return true if !locked?(section)

    # find if user has a lock for this section
    edit_locks.detect {|lock| lock[:locked_by_id] == user.id and lock[:update_section] == section}
  end

  # :call-seq:
  #   wiki.edit_locks => [{:locked_section => n, :update_section => k, :locked_by_id => user_id, locked_at => Time}, {...}, {...}, ...]
  #
  # accessor for +edit_locks+ attribute. The default value is +[]+
  # +locked_section+ is the index of the section the user decided to lock
  # since section indeces are unstable (deleting/inserting sections at a low number index changes all the later indexes),
  # we track +update_section+ which is the latest index identifying the section user locked
  def edit_locks
    # return [] if the attribute is not set
    read_attribute(:edit_locks) || write_attribute(:edit_locks, Array.new)
  end
  
  ##
  ## VERSIONING
  ##

  acts_as_versioned :if => :save_new_version? do 
    # these methods are added to both Wiki and Wiki::Version

    def body=(value) # :nodoc: 
      write_attribute(:body, value)
      write_attribute(:body_html, "")
    end
 
    # Clears the html rendered body (body_html). A cleared body_html will get
    # autogenerated when it is needed.
    def clear_html
      update_attribute(:body_html, nil)
    end

    # render_html is responsible for rendering wiki text to html markup.
    #
    # This rendering, however, is not handled by the wiki class: the block passed
    # to render_html() does the conversion.
    #
    # render_html() should be called whenever the body_html needs to be shown, but
    # the block will only actually get called if body_html needs updating.
    #
    # Example usage:
    #
    #   wiki.body_html # << not valid yet
    #   wiki.render_html do |text|
    #      GreenCloth.new(text).to_html
    #   end
    #   wiki.body_html # << now it is valid
    #
    def render_html(&block)
      if body.empty?
        self.body_html = "<p></p>"
      elsif body_html.empty? 
        self.body_html = block.call(body)
      end
      if body_html_changed?
        without_timestamps do
          if respond_to? :save_without_revision
            save_without_revision!
          else
            save!
          end
        end
      end
    end 
  end

  self.non_versioned_columns << 'edit_locks' << 'lock_version'


  # only save a new version if the body has changed
  # and was not previously nil
  def save_new_version? #:nodoc:
    self.body_changed? and self.body_was.any?
  end
  
  # returns true if the last version was created recently by this same author.
  def recent_edit_by?(author)
    (user == author) and updated_at and (updated_at > 30.minutes.ago)
  end 
  
  # returns first version since @time@
  def first_since(time)
    return nil unless time
    versions.first :conditions => ["updated_at <= :time", {:time => time}],
      :order => "updated_at DESC"
  end

  ##
  ## SAVING
  ##
  
  # 
  # a smart update of the wiki, taking into account locking
  # and the last time the wiki was saved by the same person.
  #
  # tries to save, throws an exception if anything goes wrong.
  # possible exceptions:
  #   ActiveRecord::StaleObjectError
  #   ErrorMessage
  #
  def smart_save!(params)
    restore_body(params)

    if params[:version] and version > params[:version].to_i
      raise ErrorMessage.new("can't save your data, someone else has saved new changes first.")
    end
 
    unless params[:user] and params[:user].is_a? User
      raise ErrorMessage.new("User is required.")
    end
    
    unless editable_by?(params[:user])
      raise ErrorMessage.new("Cannot save your data, someone else has locked the page.")
    end

    if recent_edit_by?(params[:user])
      save_without_revision
      versions.find_by_version(version).update_attributes(:body => body, :body_html => body_html, :updated_at => Time.now)
    else
      self.user = params[:user]
      save!
    end  
  end
  
  def restore_body(params)
    if params[:section].blank?
      # editing the whole document
      self.body = params[:body]
    else
      sections = self.sections
      sections[params[:section].to_i] = params[:body]
      self.body = sections.join('')
    end
  end

  ##### RENDERING #################################
 
  def body=(value)
    write_attribute(:body, value)
    write_attribute(:body_html, "")
  end
 
  def clear_html
    update_attribute(:body_html, nil)
  end

  # render_html is responsible for rendering wiki text to html markup.
  #
  # This rendering, however, is not handled by the wiki class: the block passed
  # to render_html() does the conversion.
  #
  # render_html() should be called whenever the body_html needs to be shown, but
  # the block will only actually get called if body_html needs updating.
  #
  # Example usage:
  #
  #   wiki.body_html # << not valid yet
  #   wiki.render_html do |text|
  #      GreenCloth.new(text).to_html
  #   end
  #   wiki.body_html # << now it is valid
  #
  def render_html(&block)
    if body.empty?
      self.body_html = "<p></p>"
    elsif body_html.empty? 
      self.body_html = block.call(body)
    end
    if body_html_changed?
      without_timestamps do
        save_without_revision!
      end
    end
  end
  
  ##
  ## RELATIONSHIP TO GROUPS
  ##
  
  # clears the rendered html. this is called
  # when a group's name is changed or some other event happens
  # which might affect how the html is rendered by wholecloth.
  # this only clears the primary group's wikis, which should be fine
  # because default_group_name just uses the primary group's name.
  def self.clear_all_html(group)
    # for wiki's owned by pages
    Wiki.connection.execute("UPDATE wikis set body_html = NULL WHERE id IN (SELECT data_id FROM pages WHERE data_type='Wiki' and group_id = #{group.id.to_i})")
    # for wiki's owned by groups
    Wiki.connection.execute("UPDATE wikis set body_html = NULL WHERE id IN (SELECT wiki_id FROM profiles WHERE entity_id = #{group.id.to_i})")
  end
  
  def default_group_name # :nodoc #
    if page and page.group_name
      #.sub(/\+.*$/,'') # remove everything after +
      page.group_name
    elsif profile
      profile.entity.name
    else
      'page'
    end
  end
  
  ##
  ## RELATIONSHIP TO PAGES
  ##
    
  # returns the page associated with this wiki, if any.
  def page
    # we do this so that we can access the page even before page or wiki are saved
    return pages.first if pages.any?
    return @page
  end
  def page=(p) #:nodoc:
    @page = p
  end
  
  #### SECTIONS ########

  # returns an array of all sections
  def sections
    GreenCloth.new(body).sections
  end


  #### PROTECTED METHODS #######
  protected

  def update_expired_locks
    @expired_locks_updated = true
    current_time = Time.zone.now

    updated_locks = edit_locks.select do |lock|
      # reject if past due and time is used
      lock[:locked_at] + LOCKING_PERIOD > current_time and !lock[:locked_at].nil?
    end

    # save locks if something changed
    update_edit_locks_attribute(updated_locks) if updated_locks != edit_locks
  end

  def update_edit_locks_attribute(updated_locks)
    without_revision do
      without_timestamps do
        update_attribute(:edit_locks, updated_locks)
      end
    end
  end

end
